/* tslint:disable */
/* eslint-disable */
/**
 * bnm
 * Books N More's API
 *
 * OpenAPI spec version: 1.0
 * Contact: samarthr1@outlook.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AdminActionInput } from '../models';
import { AdminBookByIdData } from '../models';
import { AdminBookListData } from '../models';
import { AdminEditBookByIdBody } from '../models';
import { AdminLoginBody } from '../models';
import { AdminReservedBooksBody } from '../models';
import { BaseError } from '../models';
import { CreateMemberInput } from '../models';
import { CreatePlanBody } from '../models';
import { ErrorData } from '../models';
import { GetAuthKeyRespone } from '../models';
import { InlineResponse200 } from '../models';
import { MemberAction } from '../models';
import { MemberActionInput } from '../models';
import { PlanInfo } from '../models';
import { SearchBody } from '../models';
import { SearchData } from '../models';
import { User } from '../models';
import { UserLoginBody } from '../models';
import { VerifyKeyBody } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get an auth key (Admin version)
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminGetAuthKey: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/getAuthKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Error codes to string mappper
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrorToStrings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/errorToStrings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * get an auth key
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGetAuthKey: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/getAuthKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * get a book by id
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminBookById: async (body?: MemberActionInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/bookById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * edit a book
         * @param {AdminEditBookByIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminEditBookById: async (body?: AdminEditBookByIdBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/editBookById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * login as an admin
         * @param {AdminLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminLogin: async (body?: AdminLoginBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin action to move state of a book from Reserved to ReadyToDispatch
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatch: async (body?: AdminActionInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/readyToDispatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List of books for dispatch
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatchBooks: async (body?: VerifyKeyBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/readyToDispatchBooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List of ready to return books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToReturn: async (body?: VerifyKeyBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/readyToReturn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AdminReservedBooksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReservedBooks: async (body?: AdminReservedBooksBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/reservedBooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin action to acknowledge return of book by member
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReturned: async (body?: AdminActionInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/returned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * verify an admin auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminVerifyKey: async (body?: VerifyKeyBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/verifyKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * cacnels a request for ready to return book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReadyToReturnBook: async (body?: MemberActionInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cancelReadyToReturnBook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * cancels a reservation
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReserveBook: async (body?: MemberActionInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cancelReserveBook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * create a new member
         * @param {CreateMemberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateMember: async (body?: CreateMemberInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/createMember`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a plan
         * @param {CreatePlanBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreatePlan: async (body?: CreatePlanBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/createPlan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * get hot books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetHotBooks: async (body?: VerifyKeyBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/getHotBooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * get data for home screen
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetMember: async (body?: VerifyKeyBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/getMember`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * get the plan types
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetPlanTypes: async (body?: VerifyKeyBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/getPlanTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Login
         * @param {UserLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin: async (body?: UserLoginBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * marks a book as ready to return
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReadyToReturnBook: async (body?: MemberActionInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/readyToReturnBook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * reserves a book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReserveBook: async (body?: MemberActionInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reserveBook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * search
         * @param {SearchBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearch: async (body?: SearchBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * verify an auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVerifyKey: async (body?: VerifyKeyBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/verifyKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * get an auth key (Admin version)
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdminGetAuthKey(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthKeyRespone>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getAdminGetAuthKey(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Error codes to string mappper
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getErrorToStrings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorData>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getErrorToStrings(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get an auth key
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGetAuthKey(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthKeyRespone>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getGetAuthKey(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get a book by id
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminBookById(body?: MemberActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminBookByIdData>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminBookById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * edit a book
         * @param {AdminEditBookByIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminEditBookById(body?: AdminEditBookByIdBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminEditBookById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * login as an admin
         * @param {AdminLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminLogin(body?: AdminLoginBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminLogin(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Admin action to move state of a book from Reserved to ReadyToDispatch
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminReadyToDispatch(body?: AdminActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminReadyToDispatch(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of books for dispatch
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminReadyToDispatchBooks(body?: VerifyKeyBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminBookListData>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminReadyToDispatchBooks(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of ready to return books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminReadyToReturn(body?: VerifyKeyBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminBookListData>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminReadyToReturn(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AdminReservedBooksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminReservedBooks(body?: AdminReservedBooksBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminBookListData>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminReservedBooks(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Admin action to acknowledge return of book by member
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminReturned(body?: AdminActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminReturned(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * verify an admin auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminVerifyKey(body?: VerifyKeyBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postAdminVerifyKey(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * cacnels a request for ready to return book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCancelReadyToReturnBook(body?: MemberActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberAction>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postCancelReadyToReturnBook(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * cancels a reservation
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCancelReserveBook(body?: MemberActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberAction>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postCancelReserveBook(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * create a new member
         * @param {CreateMemberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCreateMember(body?: CreateMemberInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postCreateMember(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * creates a plan
         * @param {CreatePlanBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCreatePlan(body?: CreatePlanBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postCreatePlan(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get hot books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGetHotBooks(body?: VerifyKeyBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postGetHotBooks(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get data for home screen
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGetMember(body?: VerifyKeyBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postGetMember(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get the plan types
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGetPlanTypes(body?: VerifyKeyBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanInfo>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postGetPlanTypes(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Login
         * @param {UserLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogin(body?: UserLoginBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postLogin(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * marks a book as ready to return
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReadyToReturnBook(body?: MemberActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberAction>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postReadyToReturnBook(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * reserves a book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReserveBook(body?: MemberActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberAction>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postReserveBook(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * search
         * @param {SearchBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSearch(body?: SearchBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchData>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postSearch(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * verify an auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVerifyKey(body?: VerifyKeyBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseError>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postVerifyKey(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * get an auth key (Admin version)
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminGetAuthKey(options?: any): AxiosPromise<GetAuthKeyRespone> {
            return DefaultApiFp(configuration).getAdminGetAuthKey(options).then((request) => request(axios, basePath));
        },
        /**
         * Error codes to string mappper
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrorToStrings(options?: any): AxiosPromise<ErrorData> {
            return DefaultApiFp(configuration).getErrorToStrings(options).then((request) => request(axios, basePath));
        },
        /**
         * get an auth key
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGetAuthKey(options?: any): AxiosPromise<GetAuthKeyRespone> {
            return DefaultApiFp(configuration).getGetAuthKey(options).then((request) => request(axios, basePath));
        },
        /**
         * get a book by id
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminBookById(body?: MemberActionInput, options?: any): AxiosPromise<AdminBookByIdData> {
            return DefaultApiFp(configuration).postAdminBookById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * edit a book
         * @param {AdminEditBookByIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminEditBookById(body?: AdminEditBookByIdBody, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postAdminEditBookById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * login as an admin
         * @param {AdminLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminLogin(body?: AdminLoginBody, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postAdminLogin(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin action to move state of a book from Reserved to ReadyToDispatch
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatch(body?: AdminActionInput, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postAdminReadyToDispatch(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List of books for dispatch
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatchBooks(body?: VerifyKeyBody, options?: any): AxiosPromise<AdminBookListData> {
            return DefaultApiFp(configuration).postAdminReadyToDispatchBooks(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List of ready to return books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToReturn(body?: VerifyKeyBody, options?: any): AxiosPromise<AdminBookListData> {
            return DefaultApiFp(configuration).postAdminReadyToReturn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AdminReservedBooksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReservedBooks(body?: AdminReservedBooksBody, options?: any): AxiosPromise<AdminBookListData> {
            return DefaultApiFp(configuration).postAdminReservedBooks(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin action to acknowledge return of book by member
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReturned(body?: AdminActionInput, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postAdminReturned(body, options).then((request) => request(axios, basePath));
        },
        /**
         * verify an admin auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminVerifyKey(body?: VerifyKeyBody, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postAdminVerifyKey(body, options).then((request) => request(axios, basePath));
        },
        /**
         * cacnels a request for ready to return book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReadyToReturnBook(body?: MemberActionInput, options?: any): AxiosPromise<MemberAction> {
            return DefaultApiFp(configuration).postCancelReadyToReturnBook(body, options).then((request) => request(axios, basePath));
        },
        /**
         * cancels a reservation
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReserveBook(body?: MemberActionInput, options?: any): AxiosPromise<MemberAction> {
            return DefaultApiFp(configuration).postCancelReserveBook(body, options).then((request) => request(axios, basePath));
        },
        /**
         * create a new member
         * @param {CreateMemberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateMember(body?: CreateMemberInput, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postCreateMember(body, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a plan
         * @param {CreatePlanBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreatePlan(body?: CreatePlanBody, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postCreatePlan(body, options).then((request) => request(axios, basePath));
        },
        /**
         * get hot books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetHotBooks(body?: VerifyKeyBody, options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).postGetHotBooks(body, options).then((request) => request(axios, basePath));
        },
        /**
         * get data for home screen
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetMember(body?: VerifyKeyBody, options?: any): AxiosPromise<User> {
            return DefaultApiFp(configuration).postGetMember(body, options).then((request) => request(axios, basePath));
        },
        /**
         * get the plan types
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetPlanTypes(body?: VerifyKeyBody, options?: any): AxiosPromise<PlanInfo> {
            return DefaultApiFp(configuration).postGetPlanTypes(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Login
         * @param {UserLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(body?: UserLoginBody, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postLogin(body, options).then((request) => request(axios, basePath));
        },
        /**
         * marks a book as ready to return
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReadyToReturnBook(body?: MemberActionInput, options?: any): AxiosPromise<MemberAction> {
            return DefaultApiFp(configuration).postReadyToReturnBook(body, options).then((request) => request(axios, basePath));
        },
        /**
         * reserves a book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReserveBook(body?: MemberActionInput, options?: any): AxiosPromise<MemberAction> {
            return DefaultApiFp(configuration).postReserveBook(body, options).then((request) => request(axios, basePath));
        },
        /**
         * search
         * @param {SearchBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearch(body?: SearchBody, options?: any): AxiosPromise<SearchData> {
            return DefaultApiFp(configuration).postSearch(body, options).then((request) => request(axios, basePath));
        },
        /**
         * verify an auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVerifyKey(body?: VerifyKeyBody, options?: any): AxiosPromise<BaseError> {
            return DefaultApiFp(configuration).postVerifyKey(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * get an auth key (Admin version)
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAdminGetAuthKey(options?: any) {
        return DefaultApiFp(this.configuration).getAdminGetAuthKey(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Error codes to string mappper
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getErrorToStrings(options?: any) {
        return DefaultApiFp(this.configuration).getErrorToStrings(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an auth key
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGetAuthKey(options?: any) {
        return DefaultApiFp(this.configuration).getGetAuthKey(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a book by id
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminBookById(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postAdminBookById(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * edit a book
     * @param {AdminEditBookByIdBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminEditBookById(body?: AdminEditBookByIdBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminEditBookById(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * login as an admin
     * @param {AdminLoginBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminLogin(body?: AdminLoginBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminLogin(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Admin action to move state of a book from Reserved to ReadyToDispatch
     * @param {AdminActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReadyToDispatch(body?: AdminActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReadyToDispatch(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of books for dispatch
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReadyToDispatchBooks(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReadyToDispatchBooks(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of ready to return books
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReadyToReturn(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReadyToReturn(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {AdminReservedBooksBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReservedBooks(body?: AdminReservedBooksBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReservedBooks(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Admin action to acknowledge return of book by member
     * @param {AdminActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReturned(body?: AdminActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReturned(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * verify an admin auth key
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminVerifyKey(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminVerifyKey(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * cacnels a request for ready to return book
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCancelReadyToReturnBook(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postCancelReadyToReturnBook(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * cancels a reservation
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCancelReserveBook(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postCancelReserveBook(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a new member
     * @param {CreateMemberInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCreateMember(body?: CreateMemberInput, options?: any) {
        return DefaultApiFp(this.configuration).postCreateMember(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * creates a plan
     * @param {CreatePlanBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCreatePlan(body?: CreatePlanBody, options?: any) {
        return DefaultApiFp(this.configuration).postCreatePlan(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get hot books
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGetHotBooks(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postGetHotBooks(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get data for home screen
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGetMember(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postGetMember(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the plan types
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGetPlanTypes(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postGetPlanTypes(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Login
     * @param {UserLoginBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postLogin(body?: UserLoginBody, options?: any) {
        return DefaultApiFp(this.configuration).postLogin(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * marks a book as ready to return
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postReadyToReturnBook(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postReadyToReturnBook(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * reserves a book
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postReserveBook(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postReserveBook(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * search
     * @param {SearchBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postSearch(body?: SearchBody, options?: any) {
        return DefaultApiFp(this.configuration).postSearch(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * verify an auth key
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postVerifyKey(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postVerifyKey(body, options).then((request) => request(this.axios, this.basePath));
    }
}
