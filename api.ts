/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * bnm
 * Books N More's API
 *
 * OpenAPI spec version: 1.0
 * Contact: samarthr1@outlook.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://192.168.29.45:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AdminActionInput
 */
export interface AdminActionInput {
    /**
     * 
     * @type {string}
     * @memberof AdminActionInput
     */
    authKey?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminActionInput
     */
    bookId?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminActionInput
     */
    memberId?: string;
}
/**
 * 
 * @export
 * @interface AdminBookByIdData
 */
export interface AdminBookByIdData {
    /**
     * 
     * @type {string}
     * @memberof AdminBookByIdData
     */
    ISBN?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminBookByIdData
     */
    author?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminBookByIdData
     */
    errorCode: number;
    /**
     * 
     * @type {number}
     * @memberof AdminBookByIdData
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminBookByIdData
     */
    shelfCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminBookByIdData
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface AdminBookListData
 */
export interface AdminBookListData {
    /**
     * 
     * @type {number}
     * @memberof AdminBookListData
     */
    errorCode: number;
    /**
     * 
     * @type {Array<BookData>}
     * @memberof AdminBookListData
     */
    books?: Array<BookData>;
}
/**
 * 
 * @export
 * @interface AdminEditBookByIdBody
 */
export interface AdminEditBookByIdBody {
    /**
     * 
     * @type {string}
     * @memberof AdminEditBookByIdBody
     */
    ISBN: string;
    /**
     * 
     * @type {string}
     * @memberof AdminEditBookByIdBody
     */
    author: string;
    /**
     * 
     * @type {number}
     * @memberof AdminEditBookByIdBody
     */
    bookId: number;
    /**
     * 
     * @type {string}
     * @memberof AdminEditBookByIdBody
     */
    shelfCode: string;
    /**
     * 
     * @type {string}
     * @memberof AdminEditBookByIdBody
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof AdminEditBookByIdBody
     */
    authKey: string;
}
/**
 * 
 * @export
 * @interface AdminLoginBody
 */
export interface AdminLoginBody {
    /**
     * 
     * @type {string}
     * @memberof AdminLoginBody
     */
    authKey?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminLoginBody
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminLoginBody
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface AdminReservedBooksBody
 */
export interface AdminReservedBooksBody {
    /**
     * 
     * @type {string}
     * @memberof AdminReservedBooksBody
     */
    authKey: string;
    /**
     * 
     * @type {number}
     * @memberof AdminReservedBooksBody
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminReservedBooksBody
     */
    offset?: number;
}
/**
 * 
 * @export
 * @interface BaseError
 */
export interface BaseError {
    /**
     * 
     * @type {number}
     * @memberof BaseError
     */
    errorCode?: number;
}
/**
 * 
 * @export
 * @interface BookData
 */
export interface BookData {
    /**
     * 
     * @type {number}
     * @memberof BookData
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookData
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BookData
     */
    author: string;
    /**
     * 
     * @type {number}
     * @memberof BookData
     */
    borrowedOn?: number;
    /**
     * 
     * @type {number}
     * @memberof BookData
     */
    canCancel?: number;
    /**
     * 
     * @type {string}
     * @memberof BookData
     */
    shelfCode?: string;
    /**
     * 
     * @type {number}
     * @memberof BookData
     */
    borrowerId?: number;
}
/**
 * 
 * @export
 * @interface CreateMemberInput
 */
export interface CreateMemberInput {
    /**
     * 
     * @type {string}
     * @memberof CreateMemberInput
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMemberInput
     */
    email: string;
    /**
     * 
     * @type {UserInfoAddress}
     * @memberof CreateMemberInput
     */
    address: UserInfoAddress;
    /**
     * 
     * @type {string}
     * @memberof CreateMemberInput
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMemberInput
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMemberInput
     */
    planType: string;
}
/**
 * 
 * @export
 * @interface CreatePlanBody
 */
export interface CreatePlanBody {
    /**
     * 
     * @type {string}
     * @memberof CreatePlanBody
     */
    authKey?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePlanBody
     */
    planType?: string;
}
/**
 * 
 * @export
 * @interface ErrorData
 */
export interface ErrorData {
    /**
     * 
     * @type {ErrorDataErrorStrings}
     * @memberof ErrorData
     */
    errorStrings: ErrorDataErrorStrings;
}
/**
 * 
 * @export
 * @interface ErrorDataErrorStrings
 */
export interface ErrorDataErrorStrings {
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _0: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _1: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _2: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _3: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _4: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _5: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _6: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _7: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _8: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _9: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _10: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _11: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _12: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _13: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _14: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _15: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _16: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _17: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _18: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _19: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _20: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _21: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDataErrorStrings
     */
    _22: string;
}
/**
 * 
 * @export
 * @interface GetAuthKeyRespone
 */
export interface GetAuthKeyRespone {
    /**
     * 
     * @type {string}
     * @memberof GetAuthKeyRespone
     */
    authKey?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAuthKeyRespone
     */
    errorCode?: number;
}
/**
 * 
 * @export
 * @interface HotBooks
 */
export interface HotBooks {
    /**
     * 
     * @type {string}
     * @memberof HotBooks
     */
    author: string;
    /**
     * 
     * @type {string}
     * @memberof HotBooks
     */
    image: string;
    /**
     * 
     * @type {string}
     * @memberof HotBooks
     */
    title: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    errorCode: number;
    /**
     * 
     * @type {Array<HotBooks>}
     * @memberof InlineResponse200
     */
    books?: Array<HotBooks>;
}
/**
 * 
 * @export
 * @interface MemberAction
 */
export interface MemberAction {
    /**
     * 
     * @type {number}
     * @memberof MemberAction
     */
    errorCode: number;
    /**
     * 
     * @type {User}
     * @memberof MemberAction
     */
    memberData?: User;
}
/**
 * 
 * @export
 * @interface MemberActionInput
 */
export interface MemberActionInput {
    /**
     * 
     * @type {string}
     * @memberof MemberActionInput
     */
    athKey?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberActionInput
     */
    bookId?: string;
}
/**
 * 
 * @export
 * @interface PlanData
 */
export interface PlanData {
    /**
     * 
     * @type {string}
     * @memberof PlanData
     */
    duration: string;
    /**
     * 
     * @type {number}
     * @memberof PlanData
     */
    nextRenewal: number;
    /**
     * 
     * @type {number}
     * @memberof PlanData
     */
    planId: number;
    /**
     * 
     * @type {string}
     * @memberof PlanData
     */
    canDelete: string;
    /**
     * 
     * @type {number}
     * @memberof PlanData
     */
    balanceDue: number;
}
/**
 * 
 * @export
 * @interface PlanInfo
 */
export interface PlanInfo {
    /**
     * 
     * @type {number}
     * @memberof PlanInfo
     */
    deposit: number;
    /**
     * 
     * @type {number}
     * @memberof PlanInfo
     */
    errorCode: number;
    /**
     * 
     * @type {number}
     * @memberof PlanInfo
     */
    joiningFee: number;
    /**
     * 
     * @type {Array<PlanInfoPlans>}
     * @memberof PlanInfo
     */
    plans: Array<PlanInfoPlans>;
}
/**
 * 
 * @export
 * @interface PlanInfoPlans
 */
export interface PlanInfoPlans {
    /**
     * 
     * @type {number}
     * @memberof PlanInfoPlans
     */
    cost: number;
    /**
     * 
     * @type {string}
     * @memberof PlanInfoPlans
     */
    duration: string;
    /**
     * 
     * @type {number}
     * @memberof PlanInfoPlans
     */
    numDeliveries: number;
    /**
     * 
     * @type {string}
     * @memberof PlanInfoPlans
     */
    planType: string;
}
/**
 * 
 * @export
 * @interface SearchBody
 */
export interface SearchBody {
    /**
     * 
     * @type {string}
     * @memberof SearchBody
     */
    authKey?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchBody
     */
    search?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchBody
     */
    startBook?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchBody
     */
    numBooks?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchBody
     */
    booksMatched?: number;
}
/**
 * 
 * @export
 * @interface SearchData
 */
export interface SearchData {
    /**
     * 
     * @type {number}
     * @memberof SearchData
     */
    startBook?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchData
     */
    booksMatched?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchData
     */
    endBook?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchData
     */
    errorCode?: number;
    /**
     * 
     * @type {Array<BookData>}
     * @memberof SearchData
     */
    books?: Array<BookData>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    errorCode: number;
    /**
     * 
     * @type {UserInfo}
     * @memberof User
     */
    userDetails?: UserInfo;
    /**
     * 
     * @type {Array<PlanData>}
     * @memberof User
     */
    plans?: Array<PlanData>;
    /**
     * 
     * @type {UserBooks}
     * @memberof User
     */
    books?: UserBooks;
}
/**
 * 
 * @export
 * @interface UserBooks
 */
export interface UserBooks {
    /**
     * 
     * @type {Array<BookData>}
     * @memberof UserBooks
     */
    borrowed?: Array<BookData>;
    /**
     * 
     * @type {Array<BookData>}
     * @memberof UserBooks
     */
    reserved?: Array<BookData>;
    /**
     * 
     * @type {Array<BookData>}
     * @memberof UserBooks
     */
    readyForReturn?: Array<BookData>;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    userType: number;
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    numDeliveries: number;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    sex: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    phone: string;
    /**
     * 
     * @type {UserInfoAddress}
     * @memberof UserInfo
     */
    address: UserInfoAddress;
}
/**
 * 
 * @export
 * @interface UserInfoAddress
 */
export interface UserInfoAddress {
    /**
     * 
     * @type {string}
     * @memberof UserInfoAddress
     */
    l1: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoAddress
     */
    l2: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoAddress
     */
    pincode: string;
}
/**
 * 
 * @export
 * @interface UserLoginBody
 */
export interface UserLoginBody {
    /**
     * 
     * @type {string}
     * @memberof UserLoginBody
     */
    authKey: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginBody
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginBody
     */
    password: string;
}
/**
 * 
 * @export
 * @interface VerifyKeyBody
 */
export interface VerifyKeyBody {
    /**
     * 
     * @type {string}
     * @memberof VerifyKeyBody
     */
    authKey: string;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get an auth key (Admin version)
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminGetAuthKey(options: any = {}): FetchArgs {
            const localVarPath = `/admin/getAuthKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Error codes to string mappper
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrorToStrings(options: any = {}): FetchArgs {
            const localVarPath = `/errorToStrings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an auth key
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGetAuthKey(options: any = {}): FetchArgs {
            const localVarPath = `/getAuthKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a book by id
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminBookById(body?: MemberActionInput, options: any = {}): FetchArgs {
            const localVarPath = `/admin/bookById`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MemberActionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * edit a book
         * @param {AdminEditBookByIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminEditBookById(body?: AdminEditBookByIdBody, options: any = {}): FetchArgs {
            const localVarPath = `/admin/editBookById`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminEditBookByIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * login as an admin
         * @param {AdminLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminLogin(body?: AdminLoginBody, options: any = {}): FetchArgs {
            const localVarPath = `/admin/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminLoginBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin action to move state of a book from Reserved to ReadyToDispatch
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatch(body?: AdminActionInput, options: any = {}): FetchArgs {
            const localVarPath = `/admin/readyToDispatch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminActionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of books for dispatch
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatchBooks(body?: VerifyKeyBody, options: any = {}): FetchArgs {
            const localVarPath = `/admin/readyToDispatchBooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyKeyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of ready to return books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToReturn(body?: VerifyKeyBody, options: any = {}): FetchArgs {
            const localVarPath = `/admin/readyToReturn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyKeyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AdminReservedBooksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReservedBooks(body?: AdminReservedBooksBody, options: any = {}): FetchArgs {
            const localVarPath = `/admin/reservedBooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminReservedBooksBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin action to acknowledge return of book by member
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReturned(body?: AdminActionInput, options: any = {}): FetchArgs {
            const localVarPath = `/admin/returned`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminActionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * verify an admin auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminVerifyKey(body?: VerifyKeyBody, options: any = {}): FetchArgs {
            const localVarPath = `/admin/verifyKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyKeyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * cacnels a request for ready to return book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReadyToReturnBook(body?: MemberActionInput, options: any = {}): FetchArgs {
            const localVarPath = `/cancelReadyToReturnBook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MemberActionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * cancels a reservation
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReserveBook(body?: MemberActionInput, options: any = {}): FetchArgs {
            const localVarPath = `/cancelReserveBook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MemberActionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a new member
         * @param {CreateMemberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateMember(body?: CreateMemberInput, options: any = {}): FetchArgs {
            const localVarPath = `/createMember`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMemberInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a plan
         * @param {CreatePlanBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreatePlan(body?: CreatePlanBody, options: any = {}): FetchArgs {
            const localVarPath = `/createPlan`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePlanBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get hot books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetHotBooks(body?: VerifyKeyBody, options: any = {}): FetchArgs {
            const localVarPath = `/getHotBooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyKeyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get data for home screen
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetMember(body?: VerifyKeyBody, options: any = {}): FetchArgs {
            const localVarPath = `/getMember`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyKeyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get the plan types
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetPlanTypes(body?: VerifyKeyBody, options: any = {}): FetchArgs {
            const localVarPath = `/getPlanTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyKeyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login
         * @param {UserLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(body?: UserLoginBody, options: any = {}): FetchArgs {
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserLoginBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * marks a book as ready to return
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReadyToReturnBook(body?: MemberActionInput, options: any = {}): FetchArgs {
            const localVarPath = `/readyToReturnBook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MemberActionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * reserves a book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReserveBook(body?: MemberActionInput, options: any = {}): FetchArgs {
            const localVarPath = `/reserveBook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MemberActionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search
         * @param {SearchBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearch(body?: SearchBody, options: any = {}): FetchArgs {
            const localVarPath = `/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SearchBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * verify an auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVerifyKey(body?: VerifyKeyBody, options: any = {}): FetchArgs {
            const localVarPath = `/verifyKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyKeyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * get an auth key (Admin version)
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminGetAuthKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAuthKeyRespone> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getAdminGetAuthKey(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Error codes to string mappper
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrorToStrings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ErrorData> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getErrorToStrings(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get an auth key
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGetAuthKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAuthKeyRespone> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getGetAuthKey(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get a book by id
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminBookById(body?: MemberActionInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminBookByIdData> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminBookById(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * edit a book
         * @param {AdminEditBookByIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminEditBookById(body?: AdminEditBookByIdBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminEditBookById(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * login as an admin
         * @param {AdminLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminLogin(body?: AdminLoginBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminLogin(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Admin action to move state of a book from Reserved to ReadyToDispatch
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatch(body?: AdminActionInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminReadyToDispatch(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List of books for dispatch
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatchBooks(body?: VerifyKeyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminBookListData> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminReadyToDispatchBooks(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List of ready to return books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToReturn(body?: VerifyKeyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminBookListData> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminReadyToReturn(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AdminReservedBooksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReservedBooks(body?: AdminReservedBooksBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminBookListData> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminReservedBooks(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Admin action to acknowledge return of book by member
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReturned(body?: AdminActionInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminReturned(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * verify an admin auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminVerifyKey(body?: VerifyKeyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postAdminVerifyKey(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * cacnels a request for ready to return book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReadyToReturnBook(body?: MemberActionInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MemberAction> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postCancelReadyToReturnBook(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * cancels a reservation
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReserveBook(body?: MemberActionInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MemberAction> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postCancelReserveBook(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * create a new member
         * @param {CreateMemberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateMember(body?: CreateMemberInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postCreateMember(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * creates a plan
         * @param {CreatePlanBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreatePlan(body?: CreatePlanBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postCreatePlan(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get hot books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetHotBooks(body?: VerifyKeyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postGetHotBooks(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get data for home screen
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetMember(body?: VerifyKeyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postGetMember(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get the plan types
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetPlanTypes(body?: VerifyKeyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlanInfo> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postGetPlanTypes(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Login
         * @param {UserLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(body?: UserLoginBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postLogin(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * marks a book as ready to return
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReadyToReturnBook(body?: MemberActionInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MemberAction> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postReadyToReturnBook(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * reserves a book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReserveBook(body?: MemberActionInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MemberAction> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postReserveBook(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * search
         * @param {SearchBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearch(body?: SearchBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchData> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postSearch(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * verify an auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVerifyKey(body?: VerifyKeyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseError> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postVerifyKey(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * get an auth key (Admin version)
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminGetAuthKey(options?: any) {
            return DefaultApiFp(configuration).getAdminGetAuthKey(options)(fetch, basePath);
        },
        /**
         * Error codes to string mappper
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrorToStrings(options?: any) {
            return DefaultApiFp(configuration).getErrorToStrings(options)(fetch, basePath);
        },
        /**
         * get an auth key
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGetAuthKey(options?: any) {
            return DefaultApiFp(configuration).getGetAuthKey(options)(fetch, basePath);
        },
        /**
         * get a book by id
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminBookById(body?: MemberActionInput, options?: any) {
            return DefaultApiFp(configuration).postAdminBookById(body, options)(fetch, basePath);
        },
        /**
         * edit a book
         * @param {AdminEditBookByIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminEditBookById(body?: AdminEditBookByIdBody, options?: any) {
            return DefaultApiFp(configuration).postAdminEditBookById(body, options)(fetch, basePath);
        },
        /**
         * login as an admin
         * @param {AdminLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminLogin(body?: AdminLoginBody, options?: any) {
            return DefaultApiFp(configuration).postAdminLogin(body, options)(fetch, basePath);
        },
        /**
         * Admin action to move state of a book from Reserved to ReadyToDispatch
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatch(body?: AdminActionInput, options?: any) {
            return DefaultApiFp(configuration).postAdminReadyToDispatch(body, options)(fetch, basePath);
        },
        /**
         * List of books for dispatch
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToDispatchBooks(body?: VerifyKeyBody, options?: any) {
            return DefaultApiFp(configuration).postAdminReadyToDispatchBooks(body, options)(fetch, basePath);
        },
        /**
         * List of ready to return books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReadyToReturn(body?: VerifyKeyBody, options?: any) {
            return DefaultApiFp(configuration).postAdminReadyToReturn(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AdminReservedBooksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReservedBooks(body?: AdminReservedBooksBody, options?: any) {
            return DefaultApiFp(configuration).postAdminReservedBooks(body, options)(fetch, basePath);
        },
        /**
         * Admin action to acknowledge return of book by member
         * @param {AdminActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminReturned(body?: AdminActionInput, options?: any) {
            return DefaultApiFp(configuration).postAdminReturned(body, options)(fetch, basePath);
        },
        /**
         * verify an admin auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminVerifyKey(body?: VerifyKeyBody, options?: any) {
            return DefaultApiFp(configuration).postAdminVerifyKey(body, options)(fetch, basePath);
        },
        /**
         * cacnels a request for ready to return book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReadyToReturnBook(body?: MemberActionInput, options?: any) {
            return DefaultApiFp(configuration).postCancelReadyToReturnBook(body, options)(fetch, basePath);
        },
        /**
         * cancels a reservation
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCancelReserveBook(body?: MemberActionInput, options?: any) {
            return DefaultApiFp(configuration).postCancelReserveBook(body, options)(fetch, basePath);
        },
        /**
         * create a new member
         * @param {CreateMemberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateMember(body?: CreateMemberInput, options?: any) {
            return DefaultApiFp(configuration).postCreateMember(body, options)(fetch, basePath);
        },
        /**
         * creates a plan
         * @param {CreatePlanBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreatePlan(body?: CreatePlanBody, options?: any) {
            return DefaultApiFp(configuration).postCreatePlan(body, options)(fetch, basePath);
        },
        /**
         * get hot books
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetHotBooks(body?: VerifyKeyBody, options?: any) {
            return DefaultApiFp(configuration).postGetHotBooks(body, options)(fetch, basePath);
        },
        /**
         * get data for home screen
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetMember(body?: VerifyKeyBody, options?: any) {
            return DefaultApiFp(configuration).postGetMember(body, options)(fetch, basePath);
        },
        /**
         * get the plan types
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGetPlanTypes(body?: VerifyKeyBody, options?: any) {
            return DefaultApiFp(configuration).postGetPlanTypes(body, options)(fetch, basePath);
        },
        /**
         * Login
         * @param {UserLoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(body?: UserLoginBody, options?: any) {
            return DefaultApiFp(configuration).postLogin(body, options)(fetch, basePath);
        },
        /**
         * marks a book as ready to return
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReadyToReturnBook(body?: MemberActionInput, options?: any) {
            return DefaultApiFp(configuration).postReadyToReturnBook(body, options)(fetch, basePath);
        },
        /**
         * reserves a book
         * @param {MemberActionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReserveBook(body?: MemberActionInput, options?: any) {
            return DefaultApiFp(configuration).postReserveBook(body, options)(fetch, basePath);
        },
        /**
         * search
         * @param {SearchBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearch(body?: SearchBody, options?: any) {
            return DefaultApiFp(configuration).postSearch(body, options)(fetch, basePath);
        },
        /**
         * verify an auth key
         * @param {VerifyKeyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVerifyKey(body?: VerifyKeyBody, options?: any) {
            return DefaultApiFp(configuration).postVerifyKey(body, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * get an auth key (Admin version)
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getAdminGetAuthKey(options?: any): Promise<GetAuthKeyRespone>;

    /**
     * Error codes to string mappper
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getErrorToStrings(options?: any): Promise<ErrorData>;

    /**
     * get an auth key
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getGetAuthKey(options?: any): Promise<GetAuthKeyRespone>;

    /**
     * get a book by id
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminBookById(body?: MemberActionInput, options?: any): Promise<AdminBookByIdData>;

    /**
     * edit a book
     * @param {AdminEditBookByIdBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminEditBookById(body?: AdminEditBookByIdBody, options?: any): Promise<BaseError>;

    /**
     * login as an admin
     * @param {AdminLoginBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminLogin(body?: AdminLoginBody, options?: any): Promise<BaseError>;

    /**
     * Admin action to move state of a book from Reserved to ReadyToDispatch
     * @param {AdminActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminReadyToDispatch(body?: AdminActionInput, options?: any): Promise<BaseError>;

    /**
     * List of books for dispatch
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminReadyToDispatchBooks(body?: VerifyKeyBody, options?: any): Promise<AdminBookListData>;

    /**
     * List of ready to return books
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminReadyToReturn(body?: VerifyKeyBody, options?: any): Promise<AdminBookListData>;

    /**
     * 
     * @param {AdminReservedBooksBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminReservedBooks(body?: AdminReservedBooksBody, options?: any): Promise<AdminBookListData>;

    /**
     * Admin action to acknowledge return of book by member
     * @param {AdminActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminReturned(body?: AdminActionInput, options?: any): Promise<BaseError>;

    /**
     * verify an admin auth key
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postAdminVerifyKey(body?: VerifyKeyBody, options?: any): Promise<BaseError>;

    /**
     * cacnels a request for ready to return book
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCancelReadyToReturnBook(body?: MemberActionInput, options?: any): Promise<MemberAction>;

    /**
     * cancels a reservation
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCancelReserveBook(body?: MemberActionInput, options?: any): Promise<MemberAction>;

    /**
     * create a new member
     * @param {CreateMemberInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCreateMember(body?: CreateMemberInput, options?: any): Promise<BaseError>;

    /**
     * creates a plan
     * @param {CreatePlanBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCreatePlan(body?: CreatePlanBody, options?: any): Promise<BaseError>;

    /**
     * get hot books
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postGetHotBooks(body?: VerifyKeyBody, options?: any): Promise<InlineResponse200>;

    /**
     * get data for home screen
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postGetMember(body?: VerifyKeyBody, options?: any): Promise<User>;

    /**
     * get the plan types
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postGetPlanTypes(body?: VerifyKeyBody, options?: any): Promise<PlanInfo>;

    /**
     * Login
     * @param {UserLoginBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postLogin(body?: UserLoginBody, options?: any): Promise<BaseError>;

    /**
     * marks a book as ready to return
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postReadyToReturnBook(body?: MemberActionInput, options?: any): Promise<MemberAction>;

    /**
     * reserves a book
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postReserveBook(body?: MemberActionInput, options?: any): Promise<MemberAction>;

    /**
     * search
     * @param {SearchBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postSearch(body?: SearchBody, options?: any): Promise<SearchData>;

    /**
     * verify an auth key
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postVerifyKey(body?: VerifyKeyBody, options?: any): Promise<BaseError>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * get an auth key (Admin version)
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAdminGetAuthKey(options?: any) {
        return DefaultApiFp(this.configuration).getAdminGetAuthKey(options)(this.fetch, this.basePath);
    }

    /**
     * Error codes to string mappper
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getErrorToStrings(options?: any) {
        return DefaultApiFp(this.configuration).getErrorToStrings(options)(this.fetch, this.basePath);
    }

    /**
     * get an auth key
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGetAuthKey(options?: any) {
        return DefaultApiFp(this.configuration).getGetAuthKey(options)(this.fetch, this.basePath);
    }

    /**
     * get a book by id
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminBookById(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postAdminBookById(body, options)(this.fetch, this.basePath);
    }

    /**
     * edit a book
     * @param {AdminEditBookByIdBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminEditBookById(body?: AdminEditBookByIdBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminEditBookById(body, options)(this.fetch, this.basePath);
    }

    /**
     * login as an admin
     * @param {AdminLoginBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminLogin(body?: AdminLoginBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminLogin(body, options)(this.fetch, this.basePath);
    }

    /**
     * Admin action to move state of a book from Reserved to ReadyToDispatch
     * @param {AdminActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReadyToDispatch(body?: AdminActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReadyToDispatch(body, options)(this.fetch, this.basePath);
    }

    /**
     * List of books for dispatch
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReadyToDispatchBooks(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReadyToDispatchBooks(body, options)(this.fetch, this.basePath);
    }

    /**
     * List of ready to return books
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReadyToReturn(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReadyToReturn(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AdminReservedBooksBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReservedBooks(body?: AdminReservedBooksBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReservedBooks(body, options)(this.fetch, this.basePath);
    }

    /**
     * Admin action to acknowledge return of book by member
     * @param {AdminActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminReturned(body?: AdminActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postAdminReturned(body, options)(this.fetch, this.basePath);
    }

    /**
     * verify an admin auth key
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAdminVerifyKey(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postAdminVerifyKey(body, options)(this.fetch, this.basePath);
    }

    /**
     * cacnels a request for ready to return book
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCancelReadyToReturnBook(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postCancelReadyToReturnBook(body, options)(this.fetch, this.basePath);
    }

    /**
     * cancels a reservation
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCancelReserveBook(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postCancelReserveBook(body, options)(this.fetch, this.basePath);
    }

    /**
     * create a new member
     * @param {CreateMemberInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCreateMember(body?: CreateMemberInput, options?: any) {
        return DefaultApiFp(this.configuration).postCreateMember(body, options)(this.fetch, this.basePath);
    }

    /**
     * creates a plan
     * @param {CreatePlanBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCreatePlan(body?: CreatePlanBody, options?: any) {
        return DefaultApiFp(this.configuration).postCreatePlan(body, options)(this.fetch, this.basePath);
    }

    /**
     * get hot books
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGetHotBooks(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postGetHotBooks(body, options)(this.fetch, this.basePath);
    }

    /**
     * get data for home screen
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGetMember(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postGetMember(body, options)(this.fetch, this.basePath);
    }

    /**
     * get the plan types
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGetPlanTypes(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postGetPlanTypes(body, options)(this.fetch, this.basePath);
    }

    /**
     * Login
     * @param {UserLoginBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postLogin(body?: UserLoginBody, options?: any) {
        return DefaultApiFp(this.configuration).postLogin(body, options)(this.fetch, this.basePath);
    }

    /**
     * marks a book as ready to return
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postReadyToReturnBook(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postReadyToReturnBook(body, options)(this.fetch, this.basePath);
    }

    /**
     * reserves a book
     * @param {MemberActionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postReserveBook(body?: MemberActionInput, options?: any) {
        return DefaultApiFp(this.configuration).postReserveBook(body, options)(this.fetch, this.basePath);
    }

    /**
     * search
     * @param {SearchBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postSearch(body?: SearchBody, options?: any) {
        return DefaultApiFp(this.configuration).postSearch(body, options)(this.fetch, this.basePath);
    }

    /**
     * verify an auth key
     * @param {VerifyKeyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postVerifyKey(body?: VerifyKeyBody, options?: any) {
        return DefaultApiFp(this.configuration).postVerifyKey(body, options)(this.fetch, this.basePath);
    }

}
